/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Mar 15 2016 21:19:45 GMT-0500 (CDT).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'deepforge/js-yaml.min',
    'common/util/guid',
    'js/RegistryKeys',
    'js/Constants',
    'js/Panels/MetaEditor/MetaEditorConstants',
    'text!deepforge/layers.yml',
    'text!./metadata.json'
], function (
    PluginConfig,
    PluginBase,
    yaml,
    generateGuid,
    REGISTRY_KEYS,
    CONSTANTS,
    META_CONSTANTS,
    DEFAULT_LAYERS,
    metadata
) {
    'use strict';

    /**
     * Initializes a new instance of CreateTorchMeta.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CreateTorchMeta.
     * @constructor
     */
    var CreateTorchMeta = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = CreateTorchMeta.metadata;
        this.metaSheets = {};
        this.sheetCounts = {};
    };

    CreateTorchMeta.metadata = JSON.parse(metadata);

    // Prototypal inheritance from PluginBase.
    CreateTorchMeta.prototype = Object.create(PluginBase.prototype);
    CreateTorchMeta.prototype.constructor = CreateTorchMeta;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CreateTorchMeta.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;

        if (!this.META.Language) {
            callback('"Language" container required to run plugin', this.result);
        }

        // Extra layer names
        this.getYamlText((err, text) => {
            if (err) {
                return callback(err, this.result);
            }

            // The format is...
            //      - (Abstract) CategoryLayerTypes
            //          - LayerName
            //              - Attributes (if exists)
            var content,
                categories,
                nodes = {};

            try {
                content = yaml.load(text);
            } catch (e) {
                return callback('YAML parse error: ' + e, this.result);
            }
            categories = Object.keys(content);
            // Create the base class, if needed
            if (!this.META.Layer) {
                this.META.Layer = this.createMetaNode('Layer', this.META.FCO);
            }

            // Create the category nodes
            categories
                .forEach(name => {
                    // Create a tab for each
                    this.metaSheets[name] = this.createMetaSheetTab(name);
                    this.sheetCounts[name] = 0;
                    nodes[name] = this.createMetaNode(name, this.META.Layer, name);
                });

            // Make them abstract
            categories
                .forEach(name => this.core.setRegistry(nodes[name], 'isAbstract', true));
            

            // Create the actual nodes
            categories.forEach(cat => {
                content[cat]
                    .forEach(name => {
                        var attrs = null;
                        if (typeof name !== 'string') {
                            attrs = name[Object.keys(name)[0]];
                            name = Object.keys(name)[0];
                        }
                        nodes[name] = this.createMetaNode(name, nodes[cat], cat, attrs);
                        // Make the node non-abstract
                        this.core.setRegistry(nodes[name], 'isAbstract', false);
                    });
            });

            self.save('CreateTorchMeta updated model.', function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                self.result.setSuccess(true);
                callback(null, self.result);
            });
        });
    };

    CreateTorchMeta.prototype.createMetaSheetTab = function (name) {
        var sheets = this.core.getRegistry(this.rootNode, REGISTRY_KEYS.META_SHEETS),
            id = META_CONSTANTS.META_ASPECT_SHEET_NAME_PREFIX + generateGuid(),
            desc = {
                SetID: id,
                order: sheets.length,
                title: name
            };

        sheets.push(desc);
        this.core.setRegistry(this.rootNode, REGISTRY_KEYS.META_SHEETS, sheets);
        return id;
    };

    CreateTorchMeta.prototype.getYamlText = function (callback) {
        var config = this.getCurrentConfig();

        if (config.layerNameHash) {
            this.blobClient.getObject(config.layerNameHash, (err, buffer) => {
                if (err) {
                    return callback(err, this.result);
                }
                var text = String.fromCharCode.apply(null, new Uint8Array(buffer));
                return callback(null, text);
            });
        } else {
            return callback(null, DEFAULT_LAYERS);
        }
    };

    CreateTorchMeta.prototype.createMetaNode = function (name, base, tabName, attrs) {
        var node,
            nodeId,
            tabId = this.metaSheets[tabName],
            position = this.getPositionFor(name, tabName);

        if (!tabId) {
            this.logger.error(`No meta sheet for ${tabName}`);
            debugger;
        }

        if (this.META[name]) {
            this.logger.warn('"' + name + '" already exists. skipping...');
            return this.META[name];
        }

        // Create a node
        node = this.core.createNode({
            parent: this.META.Language,
            base: base
        });
        nodeId = this.core.getPath(node);
        this.core.setAttribute(node, 'name', name);

        // Add it to the meta sheet
        this.core.addMember(this.rootNode, META_CONSTANTS.META_ASPECT_SET_NAME, node);
        this.core.addMember(this.rootNode, tabId, node);

        this.core.setMemberRegistry(
            this.rootNode,
            META_CONSTANTS.META_ASPECT_SET_NAME,
            nodeId,
            REGISTRY_KEYS.POSITION,
            position
        );
        this.core.setMemberRegistry(
            this.rootNode,
            tabId,
            nodeId,
            REGISTRY_KEYS.POSITION,
            position
        );

        if (attrs) {  // Add the attributes
            attrs.forEach((name, index) => {
                var desc = null;
                if (typeof name !== 'string') {
                    desc = name[Object.keys(name)[0]];
                    name = Object.keys(name)[0];
                }
                desc = desc || {};
                desc.argindex = index;
                this.addAttribute(name, node, desc);
            });
        }
        this.logger.debug(`added ${name} to the meta`);

        return node;
    };

    CreateTorchMeta.prototype.getPositionFor = function(name, tabName) {
        var index = this.sheetCounts[tabName],
            dx = 140,
            dy = 100,
            MAX_WIDTH = 1200,
            x;
            
        if (tabName === 'ConvLayer') {
            dx *= 1.3;
            dy *= 1.5;
        }

        this.sheetCounts[tabName]++;
        if (index === 0) {
            return {
                x: MAX_WIDTH/2,
                y: 50
            };
        }

        x = dx*index;
        return {
            x: x%MAX_WIDTH,
            y: Math.floor(x/MAX_WIDTH+1)*dy + 50
        };
    };

    CreateTorchMeta.prototype.addAttribute = function (name, node, def) {
        var initial,
            schema = {};

        schema.type = def.type || 'integer';
        if (schema.type === 'list') {  // FIXME: add support for lists
            schema.type = 'string';
        }

        if (def.min !== undefined) {
            schema.min = +def.min;
        }

        if (def.max !== undefined) {
            // Set the min, max
            schema.max = +def.max;
        }

        // Add the infer flag
        if (def.infer) {
            schema.infer = def.infer;
        }

        // Add the argindex flag
        schema.argindex = def.argindex;

        // Create the attribute and set the schema
        this.core.setAttributeMeta(node, name, schema);

        // Determine a default value
        initial = def.hasOwnProperty('default') ? def.default : def.min || null;
        if (schema.type === 'boolean') {
            initial = initial !== null ? initial : false;
        }
        if (initial !== null) {  // optional attribute - set default value
            this.core.setAttribute(node, name, initial);
        }
    };

    return CreateTorchMeta;
});
