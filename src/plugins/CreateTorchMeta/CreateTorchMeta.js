/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Mar 15 2016 21:19:45 GMT-0500 (CDT).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'deepforge/js-yaml.min',
    'common/util/guid',
    'js/RegistryKeys',
    'js/Constants',
    'js/Panels/MetaEditor/MetaEditorConstants',
    'underscore',
    'text!deepforge/layers.json',
    'text!./metadata.json'
], function (
    PluginConfig,
    PluginBase,
    yaml,
    generateGuid,
    REGISTRY_KEYS,
    CONSTANTS,
    META_CONSTANTS,
    _,
    DEFAULT_LAYERS,
    metadata
) {
    'use strict';

    /**
     * Initializes a new instance of CreateTorchMeta.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CreateTorchMeta.
     * @constructor
     */
    var CreateTorchMeta = function () {
        // Call base class' constructor.
        PluginBase.call(this);
        this.pluginMetadata = CreateTorchMeta.metadata;
        this.metaSheets = {};
        this.sheetCounts = {};
    };

    CreateTorchMeta.metadata = JSON.parse(metadata);

    // Prototypal inheritance from PluginBase.
    CreateTorchMeta.prototype = Object.create(PluginBase.prototype);
    CreateTorchMeta.prototype.constructor = CreateTorchMeta;

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CreateTorchMeta.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;

        if (!this.META.Language) {
            callback('"Language" container required to run plugin', this.result);
        }

        // Extra layer names
        this.getJsonLayers((err, text) => {
            if (err) {
                return callback(err, this.result);
            }

            // The format is...
            //      - (Abstract) CategoryLayerTypes
            //          - LayerName
            //              - Attributes (if exists)
            var content = {},
                categories,
                config = this.getCurrentConfig(),
                nodes = {},
                layers;

            try {
                layers = JSON.parse(text);
            } catch (e) {
                return callback('JSON parse error: ' + e, this.result);
            }
            layers.forEach(layer => {
                if (!content[layer.type]) {
                    content[layer.type] = [];
                }
                content[layer.type].push(layer);
            });

            categories = Object.keys(content);
            // Create the base class, if needed
            if (!this.META.Layer) {
                this.META.Layer = this.createMetaNode('Layer', this.META.FCO);
            }

            // Create the category nodes
            categories
                .forEach(name => {
                    // Create a tab for each
                    this.metaSheets[name] = this.createMetaSheetTab(name);
                    this.sheetCounts[name] = 0;
                    nodes[name] = this.createMetaNode(name, this.META.Layer, name);
                });

            // Make them abstract
            categories
                .forEach(name => this.core.setRegistry(nodes[name], 'isAbstract', true));

            if (config.removeOldLayers) {
                var isNewLayer = {},
                    newLayers = layers.map(layer => layer.name),
                    oldLayers,
                    oldNames;

                newLayers = newLayers.concat(categories);  // add the category nodes
                newLayers.forEach(name => isNewLayer[name] = true);

                // Set the newLayer nodes 'base' to 'Layer' so we don't accidentally
                // delete them
                newLayers
                    .map(name => this.META[name])
                    .filter(layer => !!layer)
                    .forEach(layer => this.core.setPointer(layer, 'base', this.META.Layer));

                oldLayers = Object.keys(this.META)
                        .filter(name => name !== 'Layer')
                        .map(name => this.META[name])
                        .filter(node => this.isMetaTypeOf(node, this.META.Layer))
                        .filter(node => !isNewLayer[this.core.getAttribute(node, 'name')]);

                oldNames = oldLayers.map(l => this.core.getAttribute(l, 'name'));
                // Get the old layer names
                this.logger.debug(`Removing layers: ${oldNames.join(', ')}`);
                oldLayers.forEach(layer => this.core.deleteNode(layer));
            }

            // Create the actual nodes
            categories.forEach(cat => {
                content[cat]
                    .forEach(layer => {
                        var attrs = layer.params,
                            name = layer.name;
                        nodes[name] = this.createMetaNode(name, nodes[cat], cat, attrs);
                        // Make the node non-abstract
                        this.core.setRegistry(nodes[name], 'isAbstract', false);
                    });
            });

            self.save('CreateTorchMeta updated model.', function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                self.result.setSuccess(true);
                callback(null, self.result);
            });
        });
    };

    CreateTorchMeta.prototype.removeFromMeta = function (nodeId) {
        var sheets = this.core.getRegistry(this.rootNode, REGISTRY_KEYS.META_SHEETS),
            sheet;

        // Remove from meta
        this.core.delMember(this.rootNode, META_CONSTANTS.META_ASPECT_SET_NAME, nodeId);

        // Remove from the given meta sheet
        sheet = sheets.find(sheet => {
            var paths = this.core.getMemberPaths(this.rootNode, sheet.SetID);
            return paths.indexOf(nodeId) > -1;
        });

        if (sheet) {
            this.core.delMember(this.rootNode, sheet.SetID, nodeId);
        }
    };

    CreateTorchMeta.prototype.createMetaSheetTab = function (name) {
        var sheets = this.core.getRegistry(this.rootNode, REGISTRY_KEYS.META_SHEETS),
            id = META_CONSTANTS.META_ASPECT_SHEET_NAME_PREFIX + generateGuid(),
            sheet,
            desc = {
                SetID: id,
                order: sheets.length,
                title: name
            };

        sheet = sheets.find(sheet => sheet.title === name);
        if (!sheet) {
            sheet = desc;
            this.logger.debug(`creating meta sheet "${name}"`);
            this.core.createSet(this.rootNode, sheet.SetID);
            sheets.push(sheet);
            this.core.setRegistry(this.rootNode, REGISTRY_KEYS.META_SHEETS, sheets);
        }
        return sheet.SetID;
    };

    CreateTorchMeta.prototype.getJsonLayers = function (callback) {
        var config = this.getCurrentConfig();

        if (config.layerNameHash) {
            this.blobClient.getObject(config.layerNameHash, (err, buffer) => {
                if (err) {
                    return callback(err, this.result);
                }
                var text = String.fromCharCode.apply(null, new Uint8Array(buffer));
                return callback(null, text);
            });
        } else {
            return callback(null, DEFAULT_LAYERS);
        }
    };

    CreateTorchMeta.prototype.createMetaNode = function (name, base, tabName, attrs) {
        var node = this.META[name],
            nodeId = node && this.core.getPath(node),
            tabId = this.metaSheets[tabName],
            position = this.getPositionFor(name, tabName);

        if (!tabId) {
            this.logger.error(`No meta sheet for ${tabName}`);
        }

        if (!node) {
            // Create a node
            node = this.core.createNode({
                parent: this.META.Language,
                base: base
            });
            this.core.setAttribute(node, 'name', name);

            nodeId = this.core.getPath(node);
        } else {
            // Remove from meta
            this.removeFromMeta(nodeId);
            this.core.setPointer(node, 'base', base);
        }

        // Add it to the meta sheet
        this.core.addMember(this.rootNode, META_CONSTANTS.META_ASPECT_SET_NAME, node);
        this.core.addMember(this.rootNode, tabId, node);

        this.core.setMemberRegistry(
            this.rootNode,
            META_CONSTANTS.META_ASPECT_SET_NAME,
            nodeId,
            REGISTRY_KEYS.POSITION,
            position
        );
        this.core.setMemberRegistry(
            this.rootNode,
            tabId,
            nodeId,
            REGISTRY_KEYS.POSITION,
            position
        );

        if (attrs) {  // Add the attributes
            // Remove attributes not in the given list
            var currentAttrs = this.core.getValidAttributeNames(node),
                rmAttrs;

            rmAttrs = _.difference(currentAttrs, attrs)  // old attribute names
                .filter(attr => attr !== 'name');

            if (rmAttrs.length) {
                this.logger.debug(`Removing ${rmAttrs.join(', ')} from ${name}`);
            }
            rmAttrs.forEach(attr => {
                this.core.delAttributeMeta(node, attr);
                if (this.core.getOwnAttribute(node, attr) !== undefined) {
                    this.core.delAttribute(node, attr);
                }
            });

            attrs.forEach((name, index) => {
                var desc = {};
                desc.argindex = index;
                desc.default = '';
                this.addAttribute(name, node, desc);
            });
        }
        this.logger.debug(`added ${name} to the meta`);

        return node;
    };

    CreateTorchMeta.prototype.getPositionFor = function(name, tabName) {
        var index = this.sheetCounts[tabName],
            dx = 140,
            dy = 100,
            MAX_WIDTH = 1200,
            x;

        if (tabName === 'Convolution') {
            dx *= 1.3;
            dy *= 1.5;
        }

        this.sheetCounts[tabName]++;
        if (index === 0) {
            return {
                x: MAX_WIDTH/2,
                y: 50
            };
        }

        x = dx*index;
        return {
            x: x%MAX_WIDTH,
            y: Math.floor(x/MAX_WIDTH+1)*dy + 50
        };
    };

    CreateTorchMeta.prototype.addAttribute = function (name, node, def) {
        var initial,
            schema = {};

        schema.type = def.type || 'string';
        if (schema.type === 'list') {  // FIXME: add support for lists
            schema.type = 'string';
        }

        if (def.min !== undefined) {
            schema.min = +def.min;
        }

        if (def.max !== undefined) {
            // Set the min, max
            schema.max = +def.max;
        }

        // Add the infer flag
        if (def.infer) {
            schema.infer = def.infer;
        }

        // Add the argindex flag
        schema.argindex = def.argindex;

        // Create the attribute and set the schema
        this.core.setAttributeMeta(node, name, schema);

        // Determine a default value
        initial = def.hasOwnProperty('default') ? def.default : def.min || null;
        if (schema.type === 'boolean') {
            initial = initial !== null ? initial : false;
        }
        this.core.setAttribute(node, name, initial);
    };

    return CreateTorchMeta;
});
