/* globals describe, before, after */
/*jshint node:true, mocha:true*/
/**
 * Generated by PluginGenerator 1.7.0 from webgme on Tue May 03 2016 16:52:39 GMT-0500 (CDT).
 */

'use strict';
var testFixture = require('../../globals'),
    spawn = require('child_process').spawn,
    path = testFixture.path,
    projectRoot = path.join(__dirname, '..', '..', '..'),
    SEED_DIR = path.join(testFixture.DF_SEED_DIR, 'devPipelineTests');

describe.skip('ExecutePipeline', function () {
    this.timeout(5000);
    var gmeConfig = testFixture.getGmeConfig(),
        expect = testFixture.expect,
        logger = testFixture.logger.fork('ExecutePipeline'),
        PluginCliManager = testFixture.WebGME.PluginCliManager,
        projectName = 'testProject',
        pluginName = 'ExecutePipeline',
        project,
        gmeAuth,
        storage,
        server,
        commitHash;

    before(function (done) {
        process.env.PORT = gmeConfig.server.port;
        server = spawn('npm', ['run', 'local'], {
            cwd: projectRoot
        });
        server.stdout.on('data', data => process.stdout.write('server:\t' + data));
        server.stderr.on('data', data => process.stderr.write('server:\t' + data));

        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)
            .then(function (gmeAuth_) {
                gmeAuth = gmeAuth_;
                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.
                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
                return storage.openDatabase();
            })
            .then(function () {
                var importParam = {
                    projectSeed: path.join(SEED_DIR, 'devPipelineTests.webgmex'),
                    projectName: projectName,
                    branchName: 'master',
                    logger: logger,
                    gmeConfig: gmeConfig
                };

                return testFixture.importProject(storage, importParam);
            })
            .then(function (importResult) {
                project = importResult.project;
                commitHash = importResult.commitHash;
                return project.createBranch('test', commitHash);
            })
            .nodeify(done);
    });

    after(function (done) {
        server.kill('SIGINT');  // not killing process...
        storage.closeDatabase()
            .then(function () {
                return gmeAuth.unload();
            })
            .nodeify(done);
    });

    it('should execute single job', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            context = {
                project: project,
                commitHash: commitHash,
                namespace: 'pipeline',
                branchName: 'test',
                activeNode: '/f/5'
            };

        manager.executePlugin(pluginName, {}, context, function (err, pluginResult) {
            expect(err).to.equal(null);
            expect(typeof pluginResult).to.equal('object');
            expect(pluginResult.success).to.equal(true);

            project.getBranchHash('test')
                .then(function (branchHash) {
                    expect(branchHash).to.not.equal(commitHash);
                })
                .nodeify(done);
        });
    });

    // TODO: Add more tests!
    // Also, should find a good way to mock the Executor framework
    it('should run plugin w/ references', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {
            },
            context = {
                project: project,
                commitHash: commitHash,
                namespace: 'pipeline',
                branchName: 'test',
                activeNode: '/f/G'
            };

        manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {
            expect(err).to.equal(null);
            expect(typeof pluginResult).to.equal('object');
            expect(pluginResult.success).to.equal(true);

            project.getBranchHash('test')
                .then(function (branchHash) {
                    expect(branchHash).to.not.equal(commitHash);
                })
                .nodeify(done);
        });
    });
});
