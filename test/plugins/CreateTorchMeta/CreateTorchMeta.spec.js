/*jshint node:true, mocha:true*/
/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Mar 15 2016 21:19:45 GMT-0500 (CDT).
 */

'use strict';
var testFixture = require('../../globals'),
    SEED_DIR = testFixture.path.join(testFixture.DF_SEED_DIR, 'devMinimal'),
    assert = require('assert');

describe('CreateTorchMeta', function () {
    var gmeConfig = testFixture.getGmeConfig(),
        expect = testFixture.expect,
        logger = testFixture.logger.fork('CreateTorchMeta'),
        PluginCliManager = testFixture.WebGME.PluginCliManager,
        projectName = 'testProject',
        pluginName = 'CreateTorchMeta',
        Q = testFixture.Q,
        core,
        project,
        gmeAuth,
        storage,
        commitHash;

    before(function (done) {
        testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName)
            .then(function (gmeAuth_) {
                gmeAuth = gmeAuth_;
                // This uses in memory storage. Use testFixture.getMongoStorage to persist test to database.
                storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
                return storage.openDatabase();
            })
            .then(function () {
                var importParam = {
                    projectSeed: testFixture.path.join(SEED_DIR, 'devMinimal.webgmex'),
                    projectName: projectName,
                    branchName: 'master',
                    logger: logger,
                    gmeConfig: gmeConfig
                };

                return testFixture.importProject(storage, importParam);
            })
            .then(function (importResult) {
                project = importResult.project;
                core = importResult.core;
                commitHash = importResult.commitHash;
                return project.createBranch('test', commitHash);
            })
            .nodeify(done);
    });

    after(function (done) {
        storage.closeDatabase()
            .then(function () {
                return gmeAuth.unload();
            })
            .nodeify(done);
    });

    it('should run plugin and update the branch', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {
            },
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'test',
                activeNode: '/960660211',
            };

        manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {
            expect(err).to.equal(null);
            expect(typeof pluginResult).to.equal('object');
            expect(pluginResult.success).to.equal(true);

            project.getBranchHash('test')
                .then(function (branchHash) {
                    expect(branchHash).to.not.equal(commitHash);
                })
                .nodeify(done);
        });
    });

    it('should create META nodes', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {
            },
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'test',
                activeNode: '/960660211',
            },
            META_NAMES = [  // Some Torch layer names to look up
                'ReLU',
                'LeakyReLU',
                'TemporalConvolution',
                'SpatialConvolution',
                'Linear',
                'SparseLinear'
            ];

        manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {
            expect(err).to.equal(null);
            expect(typeof pluginResult).to.equal('object');
            expect(pluginResult.success).to.equal(true);

            project.getBranchHash('test')
                .then(function (branchHash) {
                    return Q.ninvoke(project, 'loadObject', branchHash);
                })
                .then(function (commitObject) {
                    return Q.ninvoke(core, 'loadRoot', commitObject.root);
                })
                .then(function (rootNode) {
                    var metaNodes = core.getAllMetaNodes(rootNode),
                        names;
                    names = Object.keys(metaNodes)
                        .map(id => metaNodes[id])
                        .map(node => core.getAttribute(node, 'name'));

                    META_NAMES
                        .forEach(name => assert.notEqual(names.indexOf(name), -1,
                            'Missing node "' + name + '"'));
                })
                .nodeify(done);
        });
    });

    it('should place the nodes in the Language node', function (done) {
        var manager = new PluginCliManager(null, logger, gmeConfig),
            pluginConfig = {
            },
            context = {
                project: project,
                commitHash: commitHash,
                branchName: 'test',
                activeNode: '/960660211',
            };

        manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {
            expect(err).to.equal(null);
            expect(typeof pluginResult).to.equal('object');
            expect(pluginResult.success).to.equal(true);

            project.getBranchHash('test')
                .then(function (branchHash) {
                    return Q.ninvoke(project, 'loadObject', branchHash);
                })
                .then(function (commitObject) {
                    return Q.ninvoke(core, 'loadRoot', commitObject.root);
                })
                .then(function (rootNode) {
                    var metaDict = core.getAllMetaNodes(rootNode),
                        metaNodes,
                        nodes,
                        langNode;

                    metaNodes = Object.keys(metaDict)
                        .map(id => metaDict[id]);

                    langNode = metaNodes
                        .find(node => core.getAttribute(node, 'name') === 'Language' );

                    nodes = metaNodes
                        .filter(node => core.getAttribute(node, 'name') !== 'FCO' &&
                            core.getAttribute(node, 'name') !== 'Language' );

                    nodes.forEach(node => assert.equal(core.getParent(node), langNode));
                })
                .nodeify(done);
        });
    });

    // Attributes
    describe('attributes', function() {
        var rootNode,
            META = {};

        before(function(done) {
            var manager = new PluginCliManager(null, logger, gmeConfig),
                pluginConfig = {
                },
                context = {
                    project: project,
                    commitHash: commitHash,
                    branchName: 'test',
                    activeNode: '/960660211',
                };

            manager.executePlugin(pluginName, pluginConfig, context, function (err, pluginResult) {
                expect(err).to.equal(null);
                expect(typeof pluginResult).to.equal('object');
                expect(pluginResult.success).to.equal(true);

                project.getBranchHash('test')
                    .then(function (branchHash) {
                        return Q.ninvoke(project, 'loadObject', branchHash);
                    })
                    .then(function (commitObject) {
                        return Q.ninvoke(core, 'loadRoot', commitObject.root);
                    })
                    .then(function (root) {
                        rootNode = root;
                        var metaDict = core.getAllMetaNodes(rootNode);

                        // Populate the META object
                        Object.keys(metaDict)
                            .map(id => metaDict[id])
                            .forEach(node => META[core.getAttribute(node, 'name')] = node);

                    })
                    .nodeify(done);
            });
        });

        it('should add attributes', function () {
            // check that "Linear" has multiple attrs
            var attrs = core.getAttributeNames(META.Linear);
            assert.notEqual(attrs.length, 1, `missing attributes! ${attrs}`);
        });

        it('should support custom types', function () {
            // check that "Add" has a boolean attribute called 'isScalar'
            var attr = core.getAttributeMeta(META.Add, 'isScalar');
            assert.equal(attr.type, 'boolean');
        });

        it('should create integer type if none specified', function () {
            // check that "Linear" has an attribute called "output"
            var attr = core.getAttributeMeta(META.Linear, 'output');
            assert.notEqual(attr, -1);
            assert.equal(attr.type, 'integer');
        });

        it('should set "min" when specified', function () {
            var attr = core.getAttributeMeta(META.Linear, 'output');
            assert.equal(attr.min, 1);
        });

        it('should ignore "ignore" attributes', function () {
            // check that "Linear" doesn't have an attribute called "input"
            var attrs = core.getAttributeNames(META.Linear);
            assert.equal(attrs.indexOf('input'), -1);
        });
    });

});
