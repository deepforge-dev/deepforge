/*eslint-env node, mocha*/
/**
 * Generated by PluginGenerator 2.20.5 from webgme on Thu Feb 11 2021 12:20:02 GMT-0600 (Central Standard Time).
 */

const testFixture = require('../../../globals');

describe('UploadLibraryModelToBlob', function () {
    const gmeConfig = testFixture.getGmeConfig();
    const logger = testFixture.logger.fork('UploadLibraryModelToBlob');
    const PluginCliManager = testFixture.WebGME.PluginCliManager;

    const assert = require('assert');
    const {promisify} = require('util');
    const manager = new PluginCliManager(null, logger, gmeConfig);
    const pluginName = 'UploadLibraryModelToBlob';
    const projectName = 'testProject';
    const PIPELINES = '/f';
    manager.executePlugin = promisify(manager.executePlugin);
    manager.runPluginMain = promisify(manager.runPluginMain);
    let context,
        gmeAuth,
        storage;

    before(async function () {
        gmeAuth = await testFixture.clearDBAndGetGMEAuth(gmeConfig, projectName);
        storage = testFixture.getMemoryStorage(logger, gmeConfig, gmeAuth);
        await storage.openDatabase();
        const importParam = {
            projectSeed: testFixture.path.join(testFixture.DF_SEED_DIR, 'devProject', 'devProject.webgmex'),
            projectName: projectName,
            branchName: 'master',
            logger: logger,
            gmeConfig: gmeConfig
        };

        const importResult = await testFixture.importProject(storage, importParam);
        const {project, commitHash} = importResult;
        await project.createBranch('test', commitHash);
        context = {
            project: project,
            commitHash: commitHash,
            branchName: 'test',
            activeNode: PIPELINES,
            namespace: 'pipeline',
        };

    });

    after(async function () {
        await storage.closeDatabase();
        await gmeAuth.unload();
    });

    it('should return the hash in the first message', async function () {
        const plugin = await manager.initializePlugin(pluginName);
        plugin.libraries = [{
            name: 'testlib',
            models: [{
                name: 'TestOperation',
                path: 'test/assets/TestOperation.webgmexm'
            }]
        }];
        const pluginConfig = {
            libraryName: 'testlib',
            modelName: 'TestOperation',
        };
        await manager.configurePlugin(plugin, pluginConfig, context);
        const {messages} = await manager.runPluginMain(plugin);
        assert.equal(messages.length, 1);
        assert.equal(messages[0].message.length, 40);
        const alphnum = /^[a-z0-9]+$/;
        assert(alphnum.test(messages[0].message));
    });

    it('should throw error if library not found', async function () {
        const plugin = await manager.initializePlugin(pluginName);
        const pluginConfig = {
            libraryName: 'IDontExist',
            modelName: 'unused',
        };
        await manager.configurePlugin(plugin, pluginConfig, context);
        await assert.rejects(
            () => manager.runPluginMain(plugin),
            /Library not found/
        );
    });

    it('should throw error if model not found', async function () {
        const plugin = await manager.initializePlugin(pluginName);
        plugin.libraries = [{
            name: 'testlib',
            models: []
        }];
        const pluginConfig = {
            libraryName: 'testlib',
            modelName: 'unused',
        };
        await manager.configurePlugin(plugin, pluginConfig, context);
        await assert.rejects(
            () => manager.runPluginMain(plugin),
            /Model not found/
        );
    });
});
